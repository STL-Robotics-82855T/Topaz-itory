#pragma once

class odometry {
public:
	pair<float, float> absolute_position = { 0.0, 0.0 }; // x is left-right, y is forward-backward, measured in inches

	// Constructor
	odometry(float _wheel_offset, float _wheel_diameter) {
		wheel_offset = _wheel_offset;
		wheel_diameter = _wheel_diameter;
		
	}


	/// @brief Gets the current position of the robot, updates every 10ms
	void get_current_position() {
		uint32_t now = pros::millis();
		
		const float inches_per_rotation = wheel_diameter * PI;

		// float previous_forward_encoder = right[0].get_position(); // using encoders for now (units in rotations)
		// odom_tracker.get_position()/36000
		float previous_forward_encoder = odom_tracker.get_position()/36000.0;
		

		float forward_encoder;
		float forward_encoder_delta;
		float forward_distance_delta;

		float previous_angle_rad = imu_sensor1.get_rotation() * (PI / 180.0); // check if this should be degrees or heading
		float angle_delta_rad;

		float theta_rad;
		float thetaM_rad;
		float radius;


		float odom_current_angle_rad = 0;


		while (true) {

			// forward_encoder = right[0].get_position() * 0.6; // using encoders for now
			
			// forward_encoder_delta = forward_encoder - previous_forward_encoder;
			// forward_distance_delta = forward_encoder_delta * inches_per_rotation;

			forward_encoder = odom_tracker.get_position()/36000.0; // using encoders for now
			forward_encoder_delta = forward_encoder - previous_forward_encoder;
			forward_distance_delta = forward_encoder_delta * inches_per_rotation;

			previous_forward_encoder = forward_encoder;

			odom_current_angle_rad = imu_sensor1.get_rotation() * (PI / 180.0);

			angle_delta_rad = (odom_current_angle_rad - previous_angle_rad);


			// Since we have traction wheels, we can assume the robot doesn't slide sideways

			if (angle_delta_rad == 0) {
				// Straight line movement
				local_offset.second = forward_distance_delta;
				local_offset.first = 0.0; // No sideways movement since we have traction wheels
			} else {
				// Arc movement
				local_offset.second = (2*sin(angle_delta_rad/2) * (forward_distance_delta/angle_delta_rad + wheel_offset));
				local_offset.first = 0.0; // No sideways movement since we have traction wheels
			}

			thetaM_rad = previous_angle_rad + angle_delta_rad/2;
			
			// theta_rad = atan2f(local_offset.second, local_offset.first);
			theta_rad = 1.5707963; // (90 deg in rad) Since x offset is always 0, we can simplify this to 90 degrees (Check if this should be 90 or 0)
			radius = local_offset.second; // Simplified from pythagorean theorem, since x is always 0
			theta_rad -= thetaM_rad;
			
			local_offset.first = radius * cos(theta_rad);
			local_offset.second = radius * sin(theta_rad);

			// Update previous angle
			previous_angle_rad = odom_current_angle_rad;

			// Update absolute position
			absolute_position.first += local_offset.first;
			absolute_position.second += local_offset.second;

			Task::delay_until(&now, 10);
		}
	}

private:
	// Offsets are measured in inches

	float wheel_offset; // Distance between the wheel and the COR of the robot
	float wheel_diameter;   // Diameter measured in inches
	pair<float, float> local_offset = { 0.0, 0.0 }; // x is left-right, y is forward-backward, measured in inches

};